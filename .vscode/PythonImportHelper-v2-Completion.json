[
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "qbittorrentapi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "qbittorrentapi",
        "description": "qbittorrentapi",
        "detail": "qbittorrentapi",
        "documentation": {}
    },
    {
        "label": "urllib3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib3",
        "description": "urllib3",
        "detail": "urllib3",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "TorrentClassifier",
        "kind": 6,
        "importPath": "src.qbt_cleanup.classifier",
        "description": "src.qbt_cleanup.classifier",
        "peekOfCode": "class TorrentClassifier:\n    \"\"\"Classifies torrents for deletion based on configured criteria.\"\"\"\n    def __init__(self, config: Config, state_manager: StateManager, \n                 fileflows: Optional[FileFlowsClient] = None):\n        \"\"\"\n        Initialize classifier.\n        Args:\n            config: Application configuration\n            state_manager: State manager for persistence\n            fileflows: Optional FileFlows client",
        "detail": "src.qbt_cleanup.classifier",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.qbt_cleanup.classifier",
        "description": "src.qbt_cleanup.classifier",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass TorrentClassifier:\n    \"\"\"Classifies torrents for deletion based on configured criteria.\"\"\"\n    def __init__(self, config: Config, state_manager: StateManager, \n                 fileflows: Optional[FileFlowsClient] = None):\n        \"\"\"\n        Initialize classifier.\n        Args:\n            config: Application configuration\n            state_manager: State manager for persistence",
        "detail": "src.qbt_cleanup.classifier",
        "documentation": {}
    },
    {
        "label": "QbtCleanup",
        "kind": 6,
        "importPath": "src.qbt_cleanup.cleanup",
        "description": "src.qbt_cleanup.cleanup",
        "peekOfCode": "class QbtCleanup:\n    \"\"\"Main cleanup orchestration class.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"\n        Initialize cleanup orchestrator.\n        Args:\n            config: Application configuration\n        \"\"\"\n        self.config = config\n        self.client = QBittorrentClient(config.connection)",
        "detail": "src.qbt_cleanup.cleanup",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.qbt_cleanup.cleanup",
        "description": "src.qbt_cleanup.cleanup",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass QbtCleanup:\n    \"\"\"Main cleanup orchestration class.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"\n        Initialize cleanup orchestrator.\n        Args:\n            config: Application configuration\n        \"\"\"\n        self.config = config",
        "detail": "src.qbt_cleanup.cleanup",
        "documentation": {}
    },
    {
        "label": "QBittorrentClient",
        "kind": 6,
        "importPath": "src.qbt_cleanup.client",
        "description": "src.qbt_cleanup.client",
        "peekOfCode": "class QBittorrentClient:\n    \"\"\"Enhanced qBittorrent client wrapper.\"\"\"\n    def __init__(self, config: ConnectionConfig):\n        \"\"\"\n        Initialize client wrapper.\n        Args:\n            config: Connection configuration\n        \"\"\"\n        self.config = config\n        self._client: Optional[qbittorrentapi.Client] = None",
        "detail": "src.qbt_cleanup.client",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.qbt_cleanup.client",
        "description": "src.qbt_cleanup.client",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass QBittorrentClient:\n    \"\"\"Enhanced qBittorrent client wrapper.\"\"\"\n    def __init__(self, config: ConnectionConfig):\n        \"\"\"\n        Initialize client wrapper.\n        Args:\n            config: Connection configuration\n        \"\"\"\n        self.config = config",
        "detail": "src.qbt_cleanup.client",
        "documentation": {}
    },
    {
        "label": "ConnectionConfig",
        "kind": 6,
        "importPath": "src.qbt_cleanup.config",
        "description": "src.qbt_cleanup.config",
        "peekOfCode": "class ConnectionConfig:\n    \"\"\"qBittorrent connection configuration.\"\"\"\n    host: str = field(default_factory=lambda: os.environ.get(\"QB_HOST\", \"localhost\"))\n    port: int = field(default_factory=lambda: parse_int(\"QB_PORT\", 8080))\n    username: str = field(default_factory=lambda: os.environ.get(\"QB_USERNAME\", \"admin\"))\n    password: str = field(default_factory=lambda: os.environ.get(\"QB_PASSWORD\", \"adminadmin\"))\n    verify_ssl: bool = field(default_factory=lambda: parse_bool(\"QB_VERIFY_SSL\", False))\n@dataclass\nclass LimitsConfig:\n    \"\"\"Torrent cleanup limits configuration.\"\"\"",
        "detail": "src.qbt_cleanup.config",
        "documentation": {}
    },
    {
        "label": "LimitsConfig",
        "kind": 6,
        "importPath": "src.qbt_cleanup.config",
        "description": "src.qbt_cleanup.config",
        "peekOfCode": "class LimitsConfig:\n    \"\"\"Torrent cleanup limits configuration.\"\"\"\n    # Fallback values\n    fallback_ratio: float = field(default_factory=lambda: parse_float(\"FALLBACK_RATIO\", 1.0, 0))\n    fallback_days: float = field(default_factory=lambda: parse_float(\"FALLBACK_DAYS\", 7.0, 0))\n    # Private torrent limits\n    private_ratio: float = field(init=False)\n    private_days: float = field(init=False)\n    # Public torrent limits  \n    public_ratio: float = field(init=False)",
        "detail": "src.qbt_cleanup.config",
        "documentation": {}
    },
    {
        "label": "BehaviorConfig",
        "kind": 6,
        "importPath": "src.qbt_cleanup.config",
        "description": "src.qbt_cleanup.config",
        "peekOfCode": "class BehaviorConfig:\n    \"\"\"Cleanup behavior configuration.\"\"\"\n    delete_files: bool = field(default_factory=lambda: parse_bool(\"DELETE_FILES\", True))\n    dry_run: bool = field(default_factory=lambda: parse_bool(\"DRY_RUN\", False))\n    # Paused-only checking\n    check_paused_only: bool = field(default_factory=lambda: parse_bool(\"CHECK_PAUSED_ONLY\", False))\n    check_private_paused_only: bool = field(init=False)\n    check_public_paused_only: bool = field(init=False)\n    # Force delete settings\n    force_delete_hours: float = field(default_factory=lambda: parse_float(\"FORCE_DELETE_AFTER_HOURS\", 0, 0))",
        "detail": "src.qbt_cleanup.config",
        "documentation": {}
    },
    {
        "label": "ScheduleConfig",
        "kind": 6,
        "importPath": "src.qbt_cleanup.config",
        "description": "src.qbt_cleanup.config",
        "peekOfCode": "class ScheduleConfig:\n    \"\"\"Schedule configuration.\"\"\"\n    interval_hours: int = field(default_factory=lambda: parse_int(\"SCHEDULE_HOURS\", 24, 1))\n    run_once: bool = field(default_factory=lambda: parse_bool(\"RUN_ONCE\", False))\n@dataclass\nclass FileFlowsConfig:\n    \"\"\"FileFlows integration configuration.\"\"\"\n    enabled: bool = field(default_factory=lambda: parse_bool(\"FILEFLOWS_ENABLED\", False))\n    host: str = field(default_factory=lambda: os.environ.get(\"FILEFLOWS_HOST\", \"localhost\"))\n    port: int = field(default_factory=lambda: parse_int(\"FILEFLOWS_PORT\", 19200))",
        "detail": "src.qbt_cleanup.config",
        "documentation": {}
    },
    {
        "label": "FileFlowsConfig",
        "kind": 6,
        "importPath": "src.qbt_cleanup.config",
        "description": "src.qbt_cleanup.config",
        "peekOfCode": "class FileFlowsConfig:\n    \"\"\"FileFlows integration configuration.\"\"\"\n    enabled: bool = field(default_factory=lambda: parse_bool(\"FILEFLOWS_ENABLED\", False))\n    host: str = field(default_factory=lambda: os.environ.get(\"FILEFLOWS_HOST\", \"localhost\"))\n    port: int = field(default_factory=lambda: parse_int(\"FILEFLOWS_PORT\", 19200))\n    timeout: int = field(default_factory=lambda: parse_int(\"FILEFLOWS_TIMEOUT\", 10, 1))\n@dataclass\nclass Config:\n    \"\"\"Main configuration container.\"\"\"\n    connection: ConnectionConfig = field(default_factory=ConnectionConfig)",
        "detail": "src.qbt_cleanup.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "src.qbt_cleanup.config",
        "description": "src.qbt_cleanup.config",
        "peekOfCode": "class Config:\n    \"\"\"Main configuration container.\"\"\"\n    connection: ConnectionConfig = field(default_factory=ConnectionConfig)\n    limits: LimitsConfig = field(default_factory=LimitsConfig)\n    behavior: BehaviorConfig = field(default_factory=BehaviorConfig)\n    schedule: ScheduleConfig = field(default_factory=ScheduleConfig)\n    fileflows: FileFlowsConfig = field(default_factory=FileFlowsConfig)\n    @classmethod\n    def from_environment(cls) -> \"Config\":\n        \"\"\"Create configuration from environment variables.\"\"\"",
        "detail": "src.qbt_cleanup.config",
        "documentation": {}
    },
    {
        "label": "TorrentState",
        "kind": 6,
        "importPath": "src.qbt_cleanup.constants",
        "description": "src.qbt_cleanup.constants",
        "peekOfCode": "class TorrentState(str, Enum):\n    \"\"\"qBittorrent torrent states.\"\"\"\n    PAUSED_UP = \"pausedUP\"\n    PAUSED_DL = \"pausedDL\"\n    DOWNLOADING = \"downloading\"\n    STALLED_DL = \"stalledDL\"\n    QUEUED_DL = \"queuedDL\"\n    ALLOCATING = \"allocating\"\n    META_DL = \"metaDL\"\n    UPLOADING = \"uploading\"",
        "detail": "src.qbt_cleanup.constants",
        "documentation": {}
    },
    {
        "label": "DeletionReason",
        "kind": 6,
        "importPath": "src.qbt_cleanup.constants",
        "description": "src.qbt_cleanup.constants",
        "peekOfCode": "class DeletionReason(str, Enum):\n    \"\"\"Reasons for torrent deletion.\"\"\"\n    RATIO_EXCEEDED = \"ratio_exceeded\"\n    TIME_EXCEEDED = \"time_exceeded\"\n    FORCE_DELETE = \"force_delete\"\n    STALLED_TOO_LONG = \"stalled_too_long\"\n    BOTH_LIMITS_EXCEEDED = \"both_limits_exceeded\"\nclass TorrentType(str, Enum):\n    \"\"\"Torrent privacy type.\"\"\"\n    PRIVATE = \"private\"",
        "detail": "src.qbt_cleanup.constants",
        "documentation": {}
    },
    {
        "label": "TorrentType",
        "kind": 6,
        "importPath": "src.qbt_cleanup.constants",
        "description": "src.qbt_cleanup.constants",
        "peekOfCode": "class TorrentType(str, Enum):\n    \"\"\"Torrent privacy type.\"\"\"\n    PRIVATE = \"private\"\n    PUBLIC = \"public\"",
        "detail": "src.qbt_cleanup.constants",
        "documentation": {}
    },
    {
        "label": "format_timestamp",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def format_timestamp(iso_timestamp: str) -> str:\n    \"\"\"Format ISO timestamp to readable format.\"\"\"\n    try:\n        dt = datetime.fromisoformat(iso_timestamp.replace('Z', '+00:00'))\n        return dt.strftime('%Y-%m-%d %H:%M:%S UTC')\n    except Exception:\n        return iso_timestamp\ndef cmd_blacklist_add(args) -> int:\n    \"\"\"Add torrent to blacklist.\"\"\"\n    state = StateManager()",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "cmd_blacklist_add",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def cmd_blacklist_add(args) -> int:\n    \"\"\"Add torrent to blacklist.\"\"\"\n    state = StateManager()\n    # Get torrent name from qBittorrent if not provided\n    name = args.name\n    if not name and not args.no_lookup:\n        try:\n            config = Config.from_environment()\n            client = QBittorrentClient(config.connection)\n            if client.connect():",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "cmd_blacklist_remove",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def cmd_blacklist_remove(args) -> int:\n    \"\"\"Remove torrent from blacklist.\"\"\"\n    state = StateManager()\n    success = state.remove_from_blacklist(args.hash)\n    if success:\n        print(f\"Removed torrent from blacklist: {args.hash[:16]}...\")\n        return 0\n    else:\n        print(f\"Torrent not found in blacklist\", file=sys.stderr)\n        return 1",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "cmd_blacklist_list",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def cmd_blacklist_list(args) -> int:\n    \"\"\"List all blacklisted torrents.\"\"\"\n    state = StateManager()\n    entries = state.get_blacklist()\n    if not entries:\n        print(\"No torrents in blacklist\")\n        return 0\n    print(f\"Blacklisted torrents ({len(entries)}):\")\n    print()\n    for entry in entries:",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "cmd_blacklist_clear",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def cmd_blacklist_clear(args) -> int:\n    \"\"\"Clear all blacklisted torrents.\"\"\"\n    state = StateManager()\n    if not args.yes:\n        response = input(\"Are you sure you want to clear the entire blacklist? (y/N): \")\n        if response.lower() not in ('y', 'yes'):\n            print(\"Cancelled\")\n            return 0\n    success = state.clear_blacklist()\n    if success:",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "cmd_status",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def cmd_status(args) -> int:\n    \"\"\"Show status information.\"\"\"\n    state = StateManager()\n    if not state.state_enabled:\n        print(\"State: DISABLED (database not accessible)\")\n        return 1\n    print(\"State: ENABLED\")\n    print(f\"Database: {state.state_file}\")\n    print()\n    # Get counts",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "cmd_list_torrents",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def cmd_list_torrents(args) -> int:\n    \"\"\"List tracked torrents with names from qBittorrent.\"\"\"\n    try:\n        # Get torrent info from qBittorrent\n        config = Config.from_environment()\n        client = QBittorrentClient(config.connection)\n        if not client.connect():\n            print(\"Failed to connect to qBittorrent\", file=sys.stderr)\n            return 1\n        torrents = client.get_torrents()",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "cmd_select_torrents",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def cmd_select_torrents(args) -> int:\n    \"\"\"Interactive torrent selection for blacklisting.\"\"\"\n    try:\n        config = Config.from_environment()\n        client = QBittorrentClient(config.connection)\n        if not client.connect():\n            print(\"Failed to connect to qBittorrent\", file=sys.stderr)\n            return 1\n        torrents = client.get_torrents()\n        client.disconnect()",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.qbt_cleanup.ctl",
        "description": "src.qbt_cleanup.ctl",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog='qbt-cleanup-ctl',\n        description='Control utility for qBittorrent cleanup tool'\n    )\n    subparsers = parser.add_subparsers(dest='command', help='Command to execute')\n    # Blacklist commands\n    blacklist_parser = subparsers.add_parser('blacklist', help='Manage blacklist')\n    blacklist_subparsers = blacklist_parser.add_subparsers(dest='blacklist_command')",
        "detail": "src.qbt_cleanup.ctl",
        "documentation": {}
    },
    {
        "label": "FileFlowsClient",
        "kind": 6,
        "importPath": "src.qbt_cleanup.fileflows",
        "description": "src.qbt_cleanup.fileflows",
        "peekOfCode": "class FileFlowsClient:\n    \"\"\"Client for FileFlows API integration.\"\"\"\n    def __init__(self, config: FileFlowsConfig):\n        \"\"\"\n        Initialize FileFlows client.\n        Args:\n            config: FileFlows configuration\n        \"\"\"\n        self.config = config\n        self.base_url = f\"http://{config.host}:{config.port}/api\"",
        "detail": "src.qbt_cleanup.fileflows",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.qbt_cleanup.fileflows",
        "description": "src.qbt_cleanup.fileflows",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass FileFlowsClient:\n    \"\"\"Client for FileFlows API integration.\"\"\"\n    def __init__(self, config: FileFlowsConfig):\n        \"\"\"\n        Initialize FileFlows client.\n        Args:\n            config: FileFlows configuration\n        \"\"\"\n        self.config = config",
        "detail": "src.qbt_cleanup.fileflows",
        "documentation": {}
    },
    {
        "label": "PrettyFormatter",
        "kind": 6,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "class PrettyFormatter(logging.Formatter):\n    \"\"\"Custom formatter with colors and clean text output.\"\"\"\n    # ANSI color codes\n    COLORS = {\n        'DEBUG': '\\033[36m',    # Cyan\n        'INFO': '\\033[32m',     # Green\n        'WARNING': '\\033[33m',  # Yellow\n        'ERROR': '\\033[31m',    # Red\n        'CRITICAL': '\\033[35m', # Magenta\n        'RESET': '\\033[0m',     # Reset",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "def setup_logging(debug=False):\n    \"\"\"Set up logging with pretty formatting.\"\"\"\n    # Remove all existing handlers\n    root_logger = logging.getLogger()\n    for handler in root_logger.handlers[:]:\n        root_logger.removeHandler(handler)\n    # Create console handler with pretty formatter\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setFormatter(PrettyFormatter(use_colors=True))\n    # Set levels",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "signal_handler",
        "kind": 2,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "def signal_handler(signum, frame):\n    \"\"\"Handle manual scan trigger signal.\"\"\"\n    logger.info(\"Manual scan triggered via signal\")\n    manual_scan_event.set()\ndef print_banner():\n    \"\"\"Print a startup banner.\"\"\"\n    banner = \"\"\"\n================================================================\n          qBittorrent Cleanup Tool v2.1\n================================================================\"\"\"",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "print_banner",
        "kind": 2,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "def print_banner():\n    \"\"\"Print a startup banner.\"\"\"\n    banner = \"\"\"\n================================================================\n          qBittorrent Cleanup Tool v2.1\n================================================================\"\"\"\n    print(banner)\ndef run_cleanup_cycle(config: Config) -> bool:\n    \"\"\"\n    Run a single cleanup cycle.",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "run_cleanup_cycle",
        "kind": 2,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "def run_cleanup_cycle(config: Config) -> bool:\n    \"\"\"\n    Run a single cleanup cycle.\n    Args:\n        config: Application configuration\n    Returns:\n        True if successful\n    \"\"\"\n    try:\n        logger.info(\"Starting cleanup cycle...\")",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "def main():\n    \"\"\"Main entry point.\"\"\"\n    # Set up pretty logging\n    setup_logging(debug=False)\n    # Print banner\n    print_banner()\n    # Load configuration\n    config = Config.from_environment()\n    # Set up signal handler for manual scan\n    signal.signal(signal.SIGUSR1, signal_handler)",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "manual_scan_event",
        "kind": 5,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "manual_scan_event = Event()\ndef signal_handler(signum, frame):\n    \"\"\"Handle manual scan trigger signal.\"\"\"\n    logger.info(\"Manual scan triggered via signal\")\n    manual_scan_event.set()\ndef print_banner():\n    \"\"\"Print a startup banner.\"\"\"\n    banner = \"\"\"\n================================================================\n          qBittorrent Cleanup Tool v2.1",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.qbt_cleanup.main",
        "description": "src.qbt_cleanup.main",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main():\n    \"\"\"Main entry point.\"\"\"\n    # Set up pretty logging\n    setup_logging(debug=False)\n    # Print banner\n    print_banner()\n    # Load configuration\n    config = Config.from_environment()\n    # Set up signal handler for manual scan",
        "detail": "src.qbt_cleanup.main",
        "documentation": {}
    },
    {
        "label": "TorrentInfo",
        "kind": 6,
        "importPath": "src.qbt_cleanup.models",
        "description": "src.qbt_cleanup.models",
        "peekOfCode": "class TorrentInfo:\n    \"\"\"Processed torrent information.\"\"\"\n    torrent: Any  # qbittorrentapi torrent object\n    hash: str\n    name: str\n    is_private: bool\n    state: str\n    ratio: float\n    seeding_time: float  # in seconds\n    files: List[str] = field(default_factory=list)",
        "detail": "src.qbt_cleanup.models",
        "documentation": {}
    },
    {
        "label": "TorrentLimits",
        "kind": 6,
        "importPath": "src.qbt_cleanup.models",
        "description": "src.qbt_cleanup.models",
        "peekOfCode": "class TorrentLimits:\n    \"\"\"Limits for a specific torrent type.\"\"\"\n    ratio: float\n    days: float\n    @property\n    def seconds(self) -> float:\n        \"\"\"Get time limit in seconds.\"\"\"\n        return self.days * SECONDS_PER_DAY\n@dataclass\nclass DeletionCandidate:",
        "detail": "src.qbt_cleanup.models",
        "documentation": {}
    },
    {
        "label": "DeletionCandidate",
        "kind": 6,
        "importPath": "src.qbt_cleanup.models",
        "description": "src.qbt_cleanup.models",
        "peekOfCode": "class DeletionCandidate:\n    \"\"\"Torrent marked for deletion.\"\"\"\n    info: TorrentInfo\n    reason: DeletionReason\n    limits: TorrentLimits\n    excess_time_hours: Optional[float] = None  # For force delete\n    stalled_days: Optional[float] = None  # For stalled downloads\n    def format_reason(self) -> str:\n        \"\"\"Format deletion reason for logging.\"\"\"\n        parts = [f\"state={self.info.state}\"]",
        "detail": "src.qbt_cleanup.models",
        "documentation": {}
    },
    {
        "label": "ClassificationResult",
        "kind": 6,
        "importPath": "src.qbt_cleanup.models",
        "description": "src.qbt_cleanup.models",
        "peekOfCode": "class ClassificationResult:\n    \"\"\"Result of torrent classification.\"\"\"\n    to_delete: List[DeletionCandidate] = field(default_factory=list)\n    stalled: List[DeletionCandidate] = field(default_factory=list)\n    paused_not_ready: List[TorrentInfo] = field(default_factory=list)\n    protected_by_fileflows: List[TorrentInfo] = field(default_factory=list)\n    @property\n    def total_deletions(self) -> int:\n        \"\"\"Total number of torrents to delete.\"\"\"\n        return len(self.to_delete) + len(self.stalled)",
        "detail": "src.qbt_cleanup.models",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "kind": 6,
        "importPath": "src.qbt_cleanup.state",
        "description": "src.qbt_cleanup.state",
        "peekOfCode": "class StateManager:\n    \"\"\"Manages persistent state for tracking torrent status over time using SQLite.\"\"\"\n    def __init__(self, state_file: str = STATE_FILE):\n        \"\"\"\n        Initialize state manager with SQLite backend.\n        Args:\n            state_file: Path to state file (will use .db extension)\n        \"\"\"\n        # Change extension to .db\n        base_path = os.path.splitext(state_file)[0]",
        "detail": "src.qbt_cleanup.state",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.qbt_cleanup.state",
        "description": "src.qbt_cleanup.state",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass StateManager:\n    \"\"\"Manages persistent state for tracking torrent status over time using SQLite.\"\"\"\n    def __init__(self, state_file: str = STATE_FILE):\n        \"\"\"\n        Initialize state manager with SQLite backend.\n        Args:\n            state_file: Path to state file (will use .db extension)\n        \"\"\"\n        # Change extension to .db",
        "detail": "src.qbt_cleanup.state",
        "documentation": {}
    },
    {
        "label": "parse_bool",
        "kind": 2,
        "importPath": "src.qbt_cleanup.utils",
        "description": "src.qbt_cleanup.utils",
        "peekOfCode": "def parse_bool(env_var: str, default: bool = False) -> bool:\n    \"\"\"\n    Parse boolean environment variable.\n    Args:\n        env_var: Environment variable name\n        default: Default value if not set\n    Returns:\n        Parsed boolean value\n    \"\"\"\n    value = os.environ.get(env_var, str(default))",
        "detail": "src.qbt_cleanup.utils",
        "documentation": {}
    },
    {
        "label": "parse_float",
        "kind": 2,
        "importPath": "src.qbt_cleanup.utils",
        "description": "src.qbt_cleanup.utils",
        "peekOfCode": "def parse_float(env_var: str, default: float, min_val: Optional[float] = None) -> float:\n    \"\"\"\n    Parse float environment variable with optional minimum value.\n    Args:\n        env_var: Environment variable name\n        default: Default value if not set\n        min_val: Minimum allowed value\n    Returns:\n        Parsed float value\n    \"\"\"",
        "detail": "src.qbt_cleanup.utils",
        "documentation": {}
    },
    {
        "label": "parse_int",
        "kind": 2,
        "importPath": "src.qbt_cleanup.utils",
        "description": "src.qbt_cleanup.utils",
        "peekOfCode": "def parse_int(env_var: str, default: int, min_val: Optional[int] = None) -> int:\n    \"\"\"\n    Parse integer environment variable with optional minimum value.\n    Args:\n        env_var: Environment variable name\n        default: Default value if not set\n        min_val: Minimum allowed value\n    Returns:\n        Parsed integer value\n    \"\"\"",
        "detail": "src.qbt_cleanup.utils",
        "documentation": {}
    },
    {
        "label": "truncate_name",
        "kind": 2,
        "importPath": "src.qbt_cleanup.utils",
        "description": "src.qbt_cleanup.utils",
        "peekOfCode": "def truncate_name(name: str, max_length: int = 60) -> str:\n    \"\"\"\n    Truncate a torrent name for display.\n    Args:\n        name: Torrent name to truncate\n        max_length: Maximum length\n    Returns:\n        Truncated name with ellipsis if needed\n    \"\"\"\n    if len(name) <= max_length:",
        "detail": "src.qbt_cleanup.utils",
        "documentation": {}
    },
    {
        "label": "format_duration",
        "kind": 2,
        "importPath": "src.qbt_cleanup.utils",
        "description": "src.qbt_cleanup.utils",
        "peekOfCode": "def format_duration(seconds: float) -> str:\n    \"\"\"\n    Format duration in seconds to human-readable string.\n    Args:\n        seconds: Duration in seconds\n    Returns:\n        Formatted string (e.g., \"2.5d\", \"3.2h\")\n    \"\"\"\n    if seconds >= SECONDS_PER_DAY:\n        return f\"{seconds / SECONDS_PER_DAY:.1f}d\"",
        "detail": "src.qbt_cleanup.utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.qbt_cleanup.utils",
        "description": "src.qbt_cleanup.utils",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef parse_bool(env_var: str, default: bool = False) -> bool:\n    \"\"\"\n    Parse boolean environment variable.\n    Args:\n        env_var: Environment variable name\n        default: Default value if not set\n    Returns:\n        Parsed boolean value\n    \"\"\"",
        "detail": "src.qbt_cleanup.utils",
        "documentation": {}
    }
]